---
title: "Course Database Generation"
author: "Robert Lee"
date: "Thursday, May 21, 2015"
output: html_document
---
## Database construction

###`DBconn()`

`DBconn()` is a function with one argument (`dbfile = "course.db"` by default), scavenged from Professor Duncan Murdoch's introduction to databases.  It uses a variety of functions from the `RSQLite` package (and the `DBI` package that `RSQLite` uses) to do its work, which is to create a connection to a database.

The `local()` function ensures that whatever is contained does not interfere with outside code.  NULL is assigned to `conn` inside a local environment (but outside of the function itself).  

Inside the function,

# Why && !is.null(conn)?  
# Isn't that assumed as part of (dbIsValid(conn))?

If `dbfile` is not missing and `conn` is not NULL, 
and `conn` is a valid connection to a database, 
disconnect `conn` from the database and assign NULL to `conn` in the local environment (but outside the function).
This resets the `conn` in the case that the database `dbfile` already connected to is missing.  

If `conn` is NULL or not a valid connection to a database, `conn` (in the local environment, outside the function) becomes a connection to the `dbfile` database.  

Return `conn`.

```
DBconn <- local({ 
  conn <- NULL
  function(dbfile = "course.db") {
    if (!missing(dbfile) && !is.null(conn)) {
      if (dbIsValid(conn))
        dbDisconnect(conn)
      conn <<- NULL
    }
    if (is.null(conn) || !dbIsValid(conn)) {
      sqlite <- SQLite()
      conn <<- dbConnect(sqlite, dbfile)
    }
    conn
  }
})
```

###`createDB()`

`createDB()` is a function with one argument (`conn = DBconn()` by default), scavenged from Professor Duncan Murdoch's introduction to databases.  The argument is the connection to the database being created.  

The first of each pair of lines assigns the contents of a `.csv` file to a data.frame (eg. `students`).  

The second of each pair of lines uses the `dbWriteTable()` function from the `SQLite` package to create a table with the second argument (eg. `"students"`) as table name from the information in the third argument, a data.frame (eg. the `students` generated by the first line).  
# How do I make a function out of the date-checking?  
# Edit creatDB manual
```
createDB <- function(conn = DBconn()) {
  students <- read.csv(system.file("csv/students.csv", package="courseDB"))
  dbWriteTable(conn, "students", students, row.names = FALSE)
  assignments <- read.csv(system.file("csv/assignments.csv", package="courseDB"))
  dbWriteTable(conn, "assignments", assignments, row.names = FALSE)
  mcAnswers <- read.csv(system.file("csv/mcAnswers.csv", package = "courseDB"))
  dbWriteTable(conn, "mcAnswers", mcAnswers, row.names = FALSE)
  longformGrades <- read.csv(system.file("csv/longformGrades.csv", package = "courseDB"))
  dbWriteTable(conn, "longformGrades", longformGrades, row.names = FALSE)
  classParticipation <- read.csv(system.file("csv/classParticipation.csv", package = "courseDB"))
  dbWriteTable(conn, "classParticipation", classParticipation, row.names = FALSE)
}
```

## Pulling information from the database

The following functions retrieve the data.frames that generated the database's tables from the database.  
```
readStudents <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from students")
}

readAssignments <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from assignments")
}

readMCAnswers <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from mcAnswers")
}

readLongformGrades <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from longformGrades")
}

readClassParticipation <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from classParticipation")
}
```

They do so by using a query to the database to pull everything from a particular table.  

## Database structure

The `course.db` database currently has 5 tables:

```
students
assignments
mcAnswers
longformGrades
classParticipation
```

`students` currently has 6 columns:  
```
ID
email
lastName
givenNames
program
notes
```

`assignments` currently has 4 columns: 
```
ID
assignmentName
date
grade
```

`mcAnswers` currently has 7 columns: 
```
ID
answer
questionNumber
questionValue
examNumber
date
examCode
```

`longformGrades` currently has 6 columns: 
```
ID
grade
questionNumber
examNumber
date
examCode
```

`classParticipation` currently has 6 columns: 
```
ID
date
attended
questionAnswered
questionAsked
participationNotes
```

## Example queries

Everything: 
```
readAllInfo <- function(conn = DBconn()) {
      dbGetQuery(conn, "select * from students as s,
                                  assignments as a,
                                  mcAnswers as m,
                                  longformGrades as l,
                                  classParticipation as c
                 where s.ID = a.ID and s.ID = m.ID and s.ID = l.ID and s.ID = c.ID")
}
```

How did jay aye do on their 2nd test?  

```

NameAndExamNumberToGrade <- function(givenNames = "jay", lastName = "aye", examNumber = "2") {
      df <- as.data.frame(cbind(givenNames, lastName))
      # 1         match name to ID
      ID <- dbGetPreparedQuery(conn = DBconn(), 
                               "SELECT ID FROM students AS s 
                                    WHERE s.givenNames = :givenNames 
                                    AND s.lastName = :lastName", 
                               bind.data = df)
      if (nrow(ID) != 1) {warning("More than one ID.")}
      # 2         match ID to answers (mcAnswers) and grades (longformGrades)
      df <- as.data.frame(cbind(ID, examNumber))
      a <- dbGetPreparedQuery(conn = DBconn(),
                              "SELECT answer, questionNumber, questionValue, examCode 
                                    FROM mcAnswers AS m 
                                    WHERE m.ID = :ID 
                                    AND m.examNumber = :examNumber",
                              bind.data = df)
      if (length(unique(a$examCode)) > 1) {warning("Exam code not unique.")}
      g <- dbGetPreparedQuery(conn = DBconn(),
                              "SELECT grade, questionNumber, examCode 
                                    FROM longformGrades AS l 
                                    WHERE l.ID = :ID 
                                    AND l.examNumber = :examNumber",
                              bind.data = df)
      if (length(unique(g$examCode)) > 1) {warning("Exam code not unique.")}
      # 3     compare answers to correct answers, grades to total grades
      df <- as.data.frame(cbind(examNumber, a$examCode[1])); colnames(df) <- c("examNumber", "examCode")
      ca <- dbGetPreparedQuery(conn = DBconn(),
                               "SELECT answer, questionNumber, questionValue 
                                    FROM mcAnswers AS m 
                                    WHERE m.ID = 999999999 
                                    AND m.examNumber = :examNumber 
                                    AND m.examCode = :examCode",
                               bind.data = df)
      tg <- dbGetPreparedQuery(conn = DBconn(),
                               "SELECT grade, questionNumber 
                                    FROM longformGrades AS l 
                                    WHERE l.ID = 999999999 
                                    AND l.examNumber = :examNumber 
                                    AND l.examCode = :examCode",
                               bind.data = df)
      # 4     tally total mark on test
      total <- (sum(as.integer(a$questionValue[a$questionNumber == ca$questionNumber 
                                              && a$answer == ca$answer])) 
               + sum(as.integer(g$grade)))
      outOf <- sum(as.integer(ca$questionValue)) + sum(as.integer(tg$grade))
      return(total/outOf)
}
```